// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User Model - Synced from Clerk
model User {
  id        String   @id // Clerk user ID (not auto-generated)
  email     String   @unique
  name      String?
  role      UserRole @default(VIEWER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

enum UserRole {
  SUPER_ADMIN // Highest authority - Controls everything including admins
  ADMIN // Can manage everything except other admins
  VIEWER // Read-only access
}

model Category {
  id          String   @id @default(cuid())
  name        String   @unique
  slug        String   @unique
  description String?
  image       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  parts Part[]

  @@map("categories")
}

model Part {
  id             String   @id @default(cuid())
  name           String
  slug           String   @unique
  description    String?
  shortDesc      String?
  partNumber     String   @unique
  price          Decimal  @db.Decimal(10, 2)
  comparePrice   Decimal? @db.Decimal(10, 2)
  inStock        Boolean  @default(true)
  stockQuantity  Int      @default(0)
  images         String[]
  specifications Json?
  compatibility  String[] // Compatible vehicle models
  categoryId     String
  featured       Boolean  @default(false)

  // Showcase fields (Phase 4.5)
  published      Boolean   @default(false)
  publishedAt    DateTime?
  views          Int       @default(0)
  showcaseOrder  Int       @default(999)
  tags           String[]  @default([])
  brand          String?
  origin         String?
  certifications String[]  @default([])
  warranty       String?
  difficulty     String?
  application    String[]  @default([])
  videoUrl       String?
  pdfUrl         String?

  // NEW Phase 5: Shopify-style inventory fields
  sku               String? // Stock Keeping Unit (optional for backward compatibility)
  barcode           String? // Barcode for scanning
  lowStockThreshold Int?    @default(10) // Alert when stock below this
  trackInventory    Boolean @default(true) // Track stock levels

  // NEW Phase 5: Shopify-style pricing fields
  hasVariants    Boolean  @default(false) // Product has variants (color, size, etc.)
  compareAtPrice Decimal? @db.Decimal(10, 2) // "Was $100, Now $80" display
  costPrice      Decimal? @db.Decimal(10, 2) // Cost for profit calculation

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  category    Category            @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  orderItems  OrderItem[]
  variants    ProductVariant[] // NEW Phase 5: Product variants relation
  collections CollectionProduct[] // NEW Phase 5: Manual collection assignment

  @@index([published, showcaseOrder])
  @@index([published, categoryId])
  @@index([published, featured])
  @@index([sku])
  @@map("parts")
}

model Customer {
  id        String   @id @default(cuid())
  email     String   @unique
  firstName String
  lastName  String
  phone     String?
  company   String?
  address   Json? // Store address as JSON
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders   Order[]
  payments Payment[]

  @@map("customers")
}

model Order {
  id              String      @id @default(cuid())
  orderNumber     String      @unique
  customerId      String
  status          OrderStatus @default(PENDING)
  totalAmount     Decimal     @db.Decimal(10, 2)
  shippingCost    Decimal     @default(0) @db.Decimal(10, 2)
  notes           String?
  shippingAddress Json
  billingAddress  Json?
  paidAt          DateTime? // NEW: Track when order was paid
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  customer   Customer    @relation(fields: [customerId], references: [id])
  orderItems OrderItem[]
  payments   Payment[]

  @@map("orders")
}

model OrderItem {
  id       String  @id @default(cuid())
  orderId  String
  partId   String
  quantity Int
  price    Decimal @db.Decimal(10, 2)

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
  part  Part  @relation(fields: [partId], references: [id])

  @@map("order_items")
}

// ============================================================
// Payment System Models (Phase: Payment Gateway)
// ============================================================

model Payment {
  id        String        @id @default(cuid())
  orderId   String
  customerId String
  
  // Payment Provider Info
  provider      PaymentProvider
  transactionId String          @unique // Stripe Payment Intent ID
  clientSecret  String?         // For frontend integration
  
  // Amount & Currency
  amount   Decimal @db.Decimal(10, 2)
  currency String  @default("USD") @db.VarChar(3)
  
  // Status & Tracking
  status         PaymentStatus
  paidAt         DateTime?
  failedAt       DateTime?
  errorMessage   String?       @db.Text
  refundedAmount Decimal       @default(0) @db.Decimal(10, 2)
  
  // Idempotency (prevent duplicate charges)
  idempotencyKey String @unique
  
  // Metadata (store additional provider-specific data)
  metadata Json?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  order    Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  customer Customer @relation(fields: [customerId], references: [id])
  refunds  Refund[]
  
  @@index([orderId])
  @@index([customerId])
  @@index([status])
  @@index([provider])
  @@index([createdAt])
  @@map("payments")
}

model WebhookLog {
  id        String          @id @default(cuid())
  provider  PaymentProvider
  eventType String // e.g., "payment_intent.succeeded"
  eventId   String          @unique // Provider's event ID (prevent replay)
  
  // Webhook Data
  payload   Json // Full webhook payload
  signature String // Webhook signature for verification
  verified  Boolean @default(false)
  
  // Processing
  processed   Boolean   @default(false)
  processedAt DateTime?
  error       String?   @db.Text
  
  createdAt DateTime @default(now())
  
  @@index([provider])
  @@index([eventType])
  @@index([processed])
  @@index([createdAt])
  @@map("webhook_logs")
}

model Refund {
  id        String       @id @default(cuid())
  paymentId String
  
  // Refund Info
  amount     Decimal      @db.Decimal(10, 2)
  currency   String       @default("USD") @db.VarChar(3)
  provider   PaymentProvider
  refundId   String       @unique // Provider's refund ID
  
  // Reason & Status
  reason      RefundReason
  status      RefundStatus
  notes       String?      @db.Text
  
  // Tracking
  processedBy  String? // Admin user ID who initiated refund
  processedAt  DateTime?
  completedAt  DateTime?
  errorMessage String?  @db.Text
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  payment Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  
  @@index([paymentId])
  @@index([status])
  @@index([provider])
  @@index([createdAt])
  @@map("refunds")
}

// ============================================================
// Payment Enums
// ============================================================

enum PaymentProvider {
  STRIPE
  PAYPAL
  SQUARE
}

enum PaymentStatus {
  PENDING // Payment initiated, awaiting confirmation
  SUCCEEDED // Payment successful
  FAILED // Payment failed
  REFUNDED // Fully refunded
  PARTIALLY_REFUNDED // Partially refunded
}

enum RefundReason {
  DUPLICATE // Duplicate charge
  FRAUDULENT // Fraudulent transaction
  CUSTOMER_REQUEST // Customer requested refund
  OTHER // Other reason
}

enum RefundStatus {
  PENDING // Refund initiated
  SUCCEEDED // Refund completed
  FAILED // Refund failed
  CANCELLED // Refund cancelled
}

model ContactMessage {
  id        String        @id @default(cuid())
  name      String
  email     String
  phone     String?
  subject   String?
  message   String
  status    MessageStatus @default(UNREAD)
  createdAt DateTime      @default(now())

  @@map("contact_messages")
}

model BlogPost {
  id            String    @id @default(cuid())
  title         String
  slug          String    @unique
  content       String
  excerpt       String?
  featuredImage String?
  published     Boolean   @default(false)
  publishedAt   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@map("blog_posts")
}

model SiteSettings {
  id        String   @id @default(cuid())
  key       String   @unique
  value     Json
  updatedAt DateTime @updatedAt

  @@map("site_settings")
}

// Phase 9: Site Settings Model
model Settings {
  id        String           @id @default(cuid())
  key       String           @unique
  value     String           @db.Text
  category  SettingsCategory
  updatedBy String?
  updatedAt DateTime         @updatedAt
  createdAt DateTime         @default(now())

  @@index([category])
  @@map("settings")
}

enum SettingsCategory {
  GENERAL
  CONTACT
  SEO
  EMAIL
  PAYMENT
  SHIPPING
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  PAID // Order paid successfully
  PAYMENT_FAILED // Payment failed
  REFUNDED // Order fully refunded
}

enum MessageStatus {
  UNREAD
  READ
  REPLIED
}

// ============================================================
// Phase 5: Navigation & Product System Models
// ============================================================

// Page Model - Custom pages with product group assignment
model Page {
  id          String  @id @default(cuid())
  title       String
  slug        String  @unique
  description String? @db.Text

  // Product Group Assignment (what products to show)
  groupType   String // "category" | "tag" | "collection" | "all"
  groupValues Json // { categoryIds?: string[], tags?: string[], collectionId?: string, showAll?: boolean, brands?: string[], origins?: string[], minPrice?: number, maxPrice?: number, inStock?: boolean }

  // Display Options
  layout       String @default("grid") // "grid" | "list"
  sortBy       String @default("name") // "name" | "price" | "newest"
  itemsPerPage Int    @default(12)

  // SEO
  metaTitle String?
  metaDesc  String?

  // Publishing
  published   Boolean   @default(false)
  publishedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  menuItems MenuItem[]

  @@index([slug])
  @@index([published])
  @@map("pages")
}

// MenuItem Model - Multi-level navigation with parent-child hierarchy
model MenuItem {
  id         String  @id @default(cuid())
  label      String // Display text in menu
  position   Int // Order in navigation (0, 1, 2, ...)
  visible    Boolean @default(true)
  openNewTab Boolean @default(false)

  // Multi-level Support (self-referential relation)
  parentId String? // NULL = top-level, ID = submenu item
  parent   MenuItem?  @relation("MenuHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children MenuItem[] @relation("MenuHierarchy")

  // Link Type: Either page or external URL
  pageId      String?
  page        Page?   @relation(fields: [pageId], references: [id], onDelete: Cascade)
  externalUrl String? // For external links (e.g., "/about", "https://...")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([parentId])
  @@index([position])
  @@index([visible])
  @@map("menu_items")
}

// Collection Model - Group products by auto-filter rules or manual selection
model Collection {
  id          String  @id @default(cuid())
  name        String
  slug        String  @unique
  description String? @db.Text

  // Auto-Filter Rules (products matching these rules auto-join collection)
  filterRules Json? // { categoryIds?: string[], brands?: string[], tags?: string[], origins?: string[], difficulties?: string[], minPrice?: number, maxPrice?: number, inStock?: boolean, featured?: boolean }

  // Manual Product Selection (optional - overrides filters)
  useManual Boolean @default(false) // Use manual selection instead of filters

  // Display Options
  layout       String @default("grid")
  sortBy       String @default("name")
  itemsPerPage Int    @default(12)

  // SEO
  metaTitle String?
  metaDesc  String?

  published   Boolean   @default(false)
  publishedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  manualProducts CollectionProduct[]

  @@index([slug])
  @@index([published])
  @@map("collections")
}

// Join table for Collection <-> Part (manual product selection)
model CollectionProduct {
  id           String @id @default(cuid())
  collectionId String
  partId       String
  position     Int    @default(0) // Manual ordering in collection

  collection Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  part       Part       @relation(fields: [partId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([collectionId, partId]) // Prevent duplicate products in same collection
  @@index([collectionId])
  @@index([partId])
  @@map("collection_products")
}

// ProductVariant Model - Shopify-style product options
model ProductVariant {
  id     String @id @default(cuid())
  partId String
  part   Part   @relation(fields: [partId], references: [id], onDelete: Cascade)

  // Variant Info
  title   String // e.g., "Red / Large", "2020-2023 Model"
  sku     String? // Optional SKU for variant
  barcode String?

  // Pricing (can override parent product)
  price          Decimal? @db.Decimal(10, 2)
  compareAtPrice Decimal? @db.Decimal(10, 2)

  // Inventory
  stockQuantity Int @default(0)

  // Options (stored as JSON)
  options Json // { "Color": "Red", "Size": "Large", "Year": "2020-2023" }

  // Status
  available Boolean @default(true)

  // Image
  image String? // Variant-specific image

  position Int @default(0) // Display order

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([partId])
  @@index([sku])
  @@map("product_variants")
}
